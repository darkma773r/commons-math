package org.apache.commons.math4.geometry.euclidean.threed;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
import org.apache.commons.math4.geometry.partitioning.BSPTree;
import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;

public class OBJWriter {

    public static void write(String file, PolyhedronsSet poly) throws IOException {
        write(new File(file), poly);
    }

    public static void write(File file, PolyhedronsSet poly) throws IOException {
        // get the vertices and faces
        MeshBuilder meshBuilder = new MeshBuilder(poly.getTolerance());
        poly.getTree(true).visit(meshBuilder);

        // write them to the file
        try (Writer writer = Files.newBufferedWriter(file.toPath())) {
            writer.write("# Generated by " + OBJWriter.class.getName() + " on " + new Date() + "\n");
            writeVertices(writer, meshBuilder.getVertices());
            writeFaces(writer, meshBuilder.getFaces());
        }
    }

    private static void writeVertices(Writer writer, List<Cartesian3D> vertices) throws IOException {
        DecimalFormat df = new DecimalFormat("0.######");

        for (Cartesian3D v : vertices) {
            writer.write("v ");
            writer.write(df.format(v.getX()));
            writer.write(" ");
            writer.write(df.format(v.getY()));
            writer.write(" ");
            writer.write(df.format(v.getZ()));
            writer.write("\n");
        }
    }

    private static void writeFaces(Writer writer, List<int[]> faces) throws IOException {
        for (int[] face : faces) {
            writer.write("f ");
            for (int idx : face) {
                writer.write(String.valueOf(idx));
                writer.write(" ");
            }
            writer.write("\n");
        }
    }

    private static class VertexComparator implements Comparator<Cartesian3D> {

        private double tolerance;

        public VertexComparator(double tolerance) {
            this.tolerance = tolerance;
        }

        @Override
        public int compare(Cartesian3D a, Cartesian3D b) {
            int result = compareDoubles(a.getX(), b.getX());
            if (result == 0) {
                result = compareDoubles(a.getY(), b.getY());
                if (result == 0) {
                    result = compareDoubles(a.getZ(), b.getZ());
                }
            }
            return result;
        }

        private int compareDoubles(double a, double b) {
            double diff = a - b;
            if (diff < -tolerance) {
                return -1;
            }
            else if (diff > tolerance) {
                return 1;
            }
            return 0;
        }
    }

    private static class MeshBuilder implements BSPTreeVisitor<Euclidean3D> {

        private final double tolerance;

        private Map<Cartesian3D, Integer> vertexIndexMap;

        private List<Cartesian3D> vertices;

        private List<int[]> faces;

        public MeshBuilder(double tolerance) {
            this.tolerance = tolerance;
            this.vertexIndexMap = new TreeMap<>(new VertexComparator(tolerance));
            this.vertices = new ArrayList<>();
            this.faces = new ArrayList<>();
        }

        public List<Cartesian3D> getVertices() {
            return vertices;
        }

        public List<int[]> getFaces() {
            return faces;
        }

        @Override
        public Order visitOrder(BSPTree<Euclidean3D> node) {
            return Order.SUB_MINUS_PLUS;
        }

        @SuppressWarnings("unchecked")
        @Override
        public void visitInternalNode(BSPTree<Euclidean3D> node) {
            BoundaryAttribute<Euclidean3D> attr = (BoundaryAttribute<Euclidean3D>) node.getAttribute();

            if (attr.getPlusOutside() != null) {
                addBoundary((SubPlane) attr.getPlusOutside());
            }
            else if (attr.getPlusInside() != null) {
                addBoundary((SubPlane) attr.getPlusInside());
            }
        }

        @Override
        public void visitLeafNode(BSPTree<Euclidean3D> node) {
            // do nothing
        }

        private void addBoundary(SubPlane subplane) {
            Plane plane = (Plane) subplane.getHyperplane();
            PolygonsSet poly = (PolygonsSet) subplane.getRemainingRegion();

            TriangleExtractor triExtractor = new TriangleExtractor(tolerance);
            poly.getTree(true).visit(triExtractor);

            Cartesian3D v1, v2, v3;
            for (Cartesian2D[] tri : triExtractor.getTriangles()) {
                v1 = plane.toSpace(tri[0]);
                v2 = plane.toSpace(tri[1]);
                v3 = plane.toSpace(tri[2]);

                faces.add(new int[] {
                        getVertexIndex(v1),
                        getVertexIndex(v2),
                        getVertexIndex(v3)
                });
            }
        }

        private int getVertexIndex(Cartesian3D v) {
            Integer idx = vertexIndexMap.get(v);
            if (idx == null) {
                idx = vertices.size() + 1; // obj indices are 1-based

                vertices.add(v);
                vertexIndexMap.put(v, idx);
            }
            return idx.intValue();
        }
    }

    private static class TriangleExtractor implements BSPTreeVisitor<Euclidean2D> {

        private double tolerance;

        private List<Cartesian2D[]> triangles = new ArrayList<>();

        public TriangleExtractor(double tolerance) {
            this.tolerance = tolerance;
        }

        public List<Cartesian2D[]> getTriangles() {
            return triangles;
        }

        @Override
        public Order visitOrder(BSPTree<Euclidean2D> node) {
            return Order.SUB_MINUS_PLUS;
        }

        @Override
        public void visitInternalNode(BSPTree<Euclidean2D> node) {
            // do nothing
        }

        @Override
        public void visitLeafNode(BSPTree<Euclidean2D> node) {
            if ((Boolean) node.getAttribute()) {
                PolygonsSet convexPoly = new PolygonsSet(node.pruneAroundConvexCell(Boolean.TRUE,
                        Boolean.FALSE, null), tolerance);

                for (Cartesian2D[] loop : convexPoly.getVertices()) {
                    if (loop.length > 0 && loop[0] != null) { // skip unclosed loops
                        addTriangles(loop);
                    }
                }
            }
        }

        private void addTriangles(Cartesian2D[] vertices) {
            // use a triangle fan to add the convex region
            for (int i=2; i<vertices.length; ++i) {
                triangles.add(new Cartesian2D[] { vertices[0], vertices[i-1], vertices[i] });
            }
        }
    }
}
